import { db } from './firebaseConfig';
import { 
  collection, 
  addDoc, 
  updateDoc, 
  deleteDoc, 
  doc, 
  onSnapshot, 
  writeBatch,
  query,
  orderBy
} from 'firebase/firestore';
import { Product, Sale } from '../types';

const PRODUCTS_COLLECTION = 'products';
const SALES_COLLECTION = 'sales';

// --- Products (Real-time) ---

// Subscribe to product updates (Real-time)
export const subscribeToProducts = (callback: (products: Product[]) => void) => {
  const q = query(collection(db, PRODUCTS_COLLECTION), orderBy('name'));
  
  return onSnapshot(q, (snapshot) => {
    const products = snapshot.docs.map(doc => ({
      id: doc.id,
      ...doc.data()
    })) as Product[];
    callback(products);
  });
};

// Add a new product (Async)
export const addProduct = async (product: Omit<Product, 'id'>): Promise<void> => {
  try {
    await addDoc(collection(db, PRODUCTS_COLLECTION), product);
  } catch (error) {
    console.error("Error adding product:", error);
    throw error;
  }
};

// Update existing product (Async)
export const updateProduct = async (product: Product): Promise<void> => {
  try {
    const productRef = doc(db, PRODUCTS_COLLECTION, product.id);
    const { id, ...data } = product; // Remove ID from data payload
    await updateDoc(productRef, data);
  } catch (error) {
    console.error("Error updating product:", error);
    throw error;
  }
};

// Delete product (Async)
export const deleteProduct = async (id: string): Promise<void> => {
  try {
    await deleteDoc(doc(db, PRODUCTS_COLLECTION, id));
  } catch (error) {
    console.error("Error deleting product:", error);
    throw error;
  }
};

// --- Sales (Real-time & Transactional) ---

// Subscribe to sales history (Real-time)
export const subscribeToSales = (callback: (sales: Sale[]) => void) => {
  const q = query(collection(db, SALES_COLLECTION), orderBy('date', 'asc')); // 'asc' for charts
  
  return onSnapshot(q, (snapshot) => {
    const sales = snapshot.docs.map(doc => ({
      id: doc.id,
      ...doc.data()
    })) as Sale[];
    callback(sales);
  });
};

// Save sale and update inventory atomically (Async)
export const saveSale = async (sale: Sale): Promise<void> => {
  try {
    const batch = writeBatch(db);

    // 1. Create the Sale Record
    const saleRef = doc(collection(db, SALES_COLLECTION));
    // Ensure we don't save the 'id' field if it's generated by Firestore, 
    // or we use the generated one.
    const saleData = { ...sale, id: saleRef.id };
    batch.set(saleRef, saleData);

    // 2. Decrement Stock for each item
    // Note: In a high-concurrency environment, you might use runTransaction. 
    // For this scale, writeBatch with numeric updates is usually sufficient, 
    // but here we are just setting the new value calculated on client.
    // Ideally, we read the server stock first.
    sale.items.forEach(item => {
        // We assume the client has valid stock data. 
        // Real-time listener ensures this is mostly true.
        const productRef = doc(db, PRODUCTS_COLLECTION, item.id);
        const newStock = Math.max(0, item.stock - item.quantity); // Calculate new stock
        batch.update(productRef, { stock: newStock });
    });

    await batch.commit();
  } catch (error) {
    console.error("Error processing sale:", error);
    throw error;
  }
};

// Helper for reports (Async One-time fetch if needed, but we use subscription usually)
export const getProductsOnce = (): Promise<Product[]> => {
    return new Promise((resolve) => {
        const unsubscribe = subscribeToProducts((data) => {
            unsubscribe();
            resolve(data);
        });
    });
};